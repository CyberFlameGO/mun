//! Generated file, do not edit by hand, see `crate/ra_tools/src/codegen`

/* automatically generated by rust-bindgen 0.54.1 */

#![allow(non_snake_case, non_camel_case_types, non_upper_case_globals)]
use crate::{StructMemoryKind, TypeGroup};

#[doc = " Represents a globally unique identifier (GUID)."]
#[doc = ""]
#[doc = " GUIDs are generated by taking the MD5 hash of a type's name."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Copy\" derive=\"Debug\" derive=\"Eq\" derive=\"PartialEq\" derive=\"Hash\" derive=\"Ord\" derive=\"PartialOrd\"></div>"]
#[repr(C)]
#[derive(Clone, Copy, Debug, Eq, PartialEq, Hash, Ord, PartialOrd)]
pub struct Guid {
    #[doc = " 16-byte MD5 hash"]
    pub b: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_Guid() {
    assert_eq!(
        ::std::mem::size_of::<Guid>(),
        16usize,
        concat!("Size of: ", stringify!(Guid))
    );
    assert_eq!(
        ::std::mem::align_of::<Guid>(),
        1usize,
        concat!("Alignment of ", stringify!(Guid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<Guid>())).b as *const _ as usize },
        0usize,
        concat!("Offset of field: ", stringify!(Guid), "::", stringify!(b))
    );
}
#[doc = " Represents the type declaration for a value type."]
#[doc = ""]
#[doc = " TODO: add support for structs, polymorphism, enumerations, type parameters, generic type definitions, and constructed generic types."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct TypeInfo {
    #[doc = " Type GUID"]
    pub guid: Guid,
    #[doc = " Type name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The exact size of the type in bits without any padding"]
    pub size_in_bits: u32,
    #[doc = " The alignment of the type"]
    pub alignment: u8,
    #[doc = " Type group"]
    pub group: TypeGroup,
}
#[test]
fn bindgen_test_layout_TypeInfo() {
    assert_eq!(
        ::std::mem::size_of::<TypeInfo>(),
        32usize,
        concat!("Size of: ", stringify!(TypeInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<TypeInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(TypeInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).guid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).name as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).size_in_bits as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(size_in_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).alignment as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(alignment)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TypeInfo>())).group as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(TypeInfo),
            "::",
            stringify!(group)
        )
    );
}
#[doc = " Represents a function signature."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionSignature {
    #[doc = " Argument types"]
    pub arg_types: *const *const TypeInfo,
    #[doc = " Optional return type"]
    pub return_type: *const TypeInfo,
    #[doc = " Number of argument types"]
    pub num_arg_types: u16,
}
#[test]
fn bindgen_test_layout_FunctionSignature() {
    assert_eq!(
        ::std::mem::size_of::<FunctionSignature>(),
        24usize,
        concat!("Size of: ", stringify!(FunctionSignature))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionSignature>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionSignature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).arg_types as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(arg_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).return_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(return_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionSignature>())).num_arg_types as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionSignature),
            "::",
            stringify!(num_arg_types)
        )
    );
}
#[doc = " Represents a function prototype. A function prototype contains the name,"]
#[doc = " type signature, but not an implementation."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionPrototype {
    #[doc = " Function name"]
    pub name: *const ::std::os::raw::c_char,
    #[doc = " The type signature of the function"]
    pub signature: FunctionSignature,
}
#[test]
fn bindgen_test_layout_FunctionPrototype() {
    assert_eq!(
        ::std::mem::size_of::<FunctionPrototype>(),
        32usize,
        concat!("Size of: ", stringify!(FunctionPrototype))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionPrototype>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionPrototype))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionPrototype>())).name as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionPrototype),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionPrototype>())).signature as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionPrototype),
            "::",
            stringify!(signature)
        )
    );
}
#[doc = " Represents a function definition. A function definition contains the name,"]
#[doc = " type signature, and a pointer to the implementation."]
#[doc = ""]
#[doc = " `fn_ptr` can be used to call the declared function."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct FunctionDefinition {
    #[doc = " Function prototype"]
    pub prototype: FunctionPrototype,
    #[doc = " Function pointer"]
    pub fn_ptr: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_FunctionDefinition() {
    assert_eq!(
        ::std::mem::size_of::<FunctionDefinition>(),
        40usize,
        concat!("Size of: ", stringify!(FunctionDefinition))
    );
    assert_eq!(
        ::std::mem::align_of::<FunctionDefinition>(),
        8usize,
        concat!("Alignment of ", stringify!(FunctionDefinition))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionDefinition>())).prototype as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionDefinition),
            "::",
            stringify!(prototype)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<FunctionDefinition>())).fn_ptr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(FunctionDefinition),
            "::",
            stringify!(fn_ptr)
        )
    );
}
#[doc = " Represents a struct declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Clone\" derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Clone, Debug)]
pub struct StructInfo {
    #[doc = " Struct fields' names"]
    pub field_names: *const *const ::std::os::raw::c_char,
    #[doc = " Struct fields' information"]
    pub field_types: *const *const TypeInfo,
    #[doc = " Struct fields' offsets"]
    pub field_offsets: *const u16,
    #[doc = " Number of fields"]
    pub num_fields: u16,
    #[doc = " Struct memory kind"]
    pub memory_kind: StructMemoryKind,
}
#[test]
fn bindgen_test_layout_StructInfo() {
    assert_eq!(
        ::std::mem::size_of::<StructInfo>(),
        32usize,
        concat!("Size of: ", stringify!(StructInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<StructInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(StructInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_names as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_names)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_types as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).field_offsets as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(field_offsets)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).num_fields as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(num_fields)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<StructInfo>())).memory_kind as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(StructInfo),
            "::",
            stringify!(memory_kind)
        )
    );
}
#[doc = " Represents a module declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct ModuleInfo {
    #[doc = " Module path"]
    pub path: *const ::std::os::raw::c_char,
    #[doc = " Module functions"]
    pub functions: *const FunctionDefinition,
    #[doc = " Number of module functions"]
    pub num_functions: u32,
    #[doc = " Module types"]
    pub types: *const *const TypeInfo,
    #[doc = " Number of module types"]
    pub num_types: u32,
}
#[test]
fn bindgen_test_layout_ModuleInfo() {
    assert_eq!(
        ::std::mem::size_of::<ModuleInfo>(),
        40usize,
        concat!("Size of: ", stringify!(ModuleInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<ModuleInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(ModuleInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).path as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).functions as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).num_functions as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(num_functions)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).types as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(types)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ModuleInfo>())).num_types as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ModuleInfo),
            "::",
            stringify!(num_types)
        )
    );
}
#[doc = " Represents a function dispatch table. This is used for runtime linking."]
#[doc = ""]
#[doc = " Function signatures and pointers are stored separately for cache efficiency."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct DispatchTable {
    #[doc = " Function signatures"]
    pub prototypes: *const FunctionPrototype,
    #[doc = " Function pointers"]
    pub fn_ptrs: *mut *const ::std::os::raw::c_void,
    #[doc = " Number of functions"]
    pub num_entries: u32,
}
#[test]
fn bindgen_test_layout_DispatchTable() {
    assert_eq!(
        ::std::mem::size_of::<DispatchTable>(),
        24usize,
        concat!("Size of: ", stringify!(DispatchTable))
    );
    assert_eq!(
        ::std::mem::align_of::<DispatchTable>(),
        8usize,
        concat!("Alignment of ", stringify!(DispatchTable))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).prototypes as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(prototypes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).fn_ptrs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(fn_ptrs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<DispatchTable>())).num_entries as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(DispatchTable),
            "::",
            stringify!(num_entries)
        )
    );
}
#[doc = " Represents an assembly declaration."]
#[doc = ""]
#[doc = " <div rustbindgen derive=\"Debug\"></div>"]
#[repr(C)]
#[derive(Debug)]
pub struct AssemblyInfo {
    #[doc = " Symbols of the top-level module"]
    pub symbols: ModuleInfo,
    #[doc = " Dispatch table"]
    pub dispatch_table: DispatchTable,
    #[doc = " Paths to assembly dependencies"]
    pub dependencies: *const *const ::std::os::raw::c_char,
    #[doc = " Number of dependencies"]
    pub num_dependencies: u32,
}
#[test]
fn bindgen_test_layout_AssemblyInfo() {
    assert_eq!(
        ::std::mem::size_of::<AssemblyInfo>(),
        80usize,
        concat!("Size of: ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<AssemblyInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(AssemblyInfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).symbols as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(symbols)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dispatch_table as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dispatch_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).dependencies as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(dependencies)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<AssemblyInfo>())).num_dependencies as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(AssemblyInfo),
            "::",
            stringify!(num_dependencies)
        )
    );
}
